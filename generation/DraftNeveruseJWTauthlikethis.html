<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=mW_CIZvkcW1i7Mw9mVo5Pw1nGhQimsDuvOKTiJCJG5Q);ul.lst-kix_djkaxc2blewf-1{list-style-type:none}.lst-kix_djkaxc2blewf-3>li:before{content:"-  "}ul.lst-kix_djkaxc2blewf-0{list-style-type:none}.lst-kix_djkaxc2blewf-0>li:before{content:"-  "}.lst-kix_djkaxc2blewf-4>li:before{content:"-  "}.lst-kix_djkaxc2blewf-6>li:before{content:"-  "}.lst-kix_djkaxc2blewf-7>li:before{content:"-  "}.lst-kix_djkaxc2blewf-5>li:before{content:"-  "}.lst-kix_djkaxc2blewf-8>li:before{content:"-  "}ul.lst-kix_djkaxc2blewf-8{list-style-type:none}ul.lst-kix_djkaxc2blewf-7{list-style-type:none}ul.lst-kix_djkaxc2blewf-6{list-style-type:none}.lst-kix_djkaxc2blewf-1>li:before{content:"-  "}ul.lst-kix_djkaxc2blewf-5{list-style-type:none}ul.lst-kix_djkaxc2blewf-4{list-style-type:none}.lst-kix_djkaxc2blewf-2>li:before{content:"-  "}ul.lst-kix_djkaxc2blewf-3{list-style-type:none}ul.lst-kix_djkaxc2blewf-2{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c6{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Ubuntu";font-style:normal}.c0{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c8{color:#000000;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Ubuntu";font-style:normal}.c9{color:#434343;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Ubuntu";font-style:normal}.c7{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c5{color:inherit;text-decoration:inherit}.c4{font-weight:700}.c2{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Ubuntu"}p{margin:0;color:#000000;font-size:11pt;font-family:"Ubuntu"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:16pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-weight:700;font-size:12pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10 doc-content"><h2 class="c6" id="h.yb2m1sqj95eo"><span class="c8 c4">Disclaimer</span></h2><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Wait, wait, wait &mdash; don&rsquo;t go away. Let me explain myself. JWT itself is a good mechanism, but the problem lies in the authorization flow that uses JWT.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">I&rsquo;m talking about clients (React, Angular, Flutter) that send a login and password to the backend and receive a JWT in response.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 498.67px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 498.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">Today, we&rsquo;ll discuss why this approach is insecure, not recommended, and what to use instead.</span></p><p class="c1 c2"><span class="c3"></span></p><h2 class="c6" id="h.17mvb353ffl9"><span class="c8 c4">The problematic flow</span></h2><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Before proceeding we should somehow name or classify this flow. Since OAuth and OpenIdConnect protocols are the leading protocols for authorization - we are going to use them.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>I have already explained all the internals of the OAuth protocol, how it works and why in </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://andreyka26.com/auth-from-backend-perspective-pt3-oauth-basics&amp;sa=D&amp;source=editors&amp;ust=1744983134511785&amp;usg=AOvVaw1k_pinyzE_CojFaaqdaAAI">one of my articles</a></span><span class="c3">, it would be great to read it as a prerequisite.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">In general OAuth has 4 different &ldquo;approaches&rdquo; or &ldquo;implementations&rdquo; for authorization called grants. They have different purposes, and different security drawbacks.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>For Resource Owner authorization (the end user) we have only 3 grants: </span><span class="c4">auth code</span><span>, </span><span class="c4">implicit</span><span>, </span><span class="c4">password credentials</span><span class="c3">.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">The &ldquo;login, password&rdquo; -&gt; JWT token flow that people are implementing everywhere is actually called `Resource Owner Password Credentials grant` or shortly `Password Credentials grant`.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>If you are interested, how this flow is implemented under hood - please have a look at this </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://andreyka26.com/jwt-auth-using-dot-net-and-react&amp;sa=D&amp;source=editors&amp;ust=1744983134512765&amp;usg=AOvVaw2-Y4jEB8QWsdIi9pCqZQCi">article</a></span><span class="c3">, where I made this auth with .net backend and react as a client</span></p><h2 class="c6" id="h.kfqf7nk9w46x"><span class="c4 c8">Why Custom Password Credentials is bad</span></h2><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>Now that we&rsquo;ve classified the flow and know that it&rsquo;s actually the </span><span class="c4">Password Credentials OAuth Grant</span><span class="c3">, let&rsquo;s look at what&rsquo;s bad about it.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">It works exactly the same as people usually implement it. The Client (browser or mobile) sends login + password over the network to the authorization server. Server checks that user with that credential exists and issues access token + refresh token (possibly).</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 390.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 390.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">The difference is that it follows the protocol, so it adds parameters like `grant_type` and `scope`. Besides that OAuth MAY have client authentication on top of resource owner (user) authentication.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Why is it bad?</span></p><p class="c1 c2"><span class="c3"></span></p><h3 class="c0" id="h.3sdpq71a6h4g"><span class="c9 c4">User&rsquo;s credentials exposure</span></h3><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>In </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://datatracker.ietf.org/doc/html/rfc6749%23section-10.7&amp;sa=D&amp;source=editors&amp;ust=1744983134514010&amp;usg=AOvVaw0FAZxgi2d9tcwQJac8g6WO">official RFC</a></span><span>&nbsp;it&rsquo;s stated that the main problem is the exposure of Resource Owner&rsquo;s (user&rsquo;s) credentials to the client, where they can be read and used in any way. Now, the security of your credentials is tied to two systems instead of one: the client and the server.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 409.33px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 409.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">Since OAuth initially was designed to handle &ldquo;third party apps&rdquo; access, it is not usually suitable for general use, when both client and server are your first party apps, basically.</span></p><p class="c1 c2"><span class="c3"></span></p><h3 class="c0" id="h.c4yudt8p97zx"><span class="c9 c4">Password Brute Force</span></h3><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Since the client fires the request (XHR), it&rsquo;s easy to perform a brute-force attack. To prevent this, you need rate limiting and similar protections.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 336.00px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 336.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c3">With the Authorization Code flow, for example &mdash; where the login UI is hosted on the Authorization Server &mdash; you can simply add anti-forgery tokens and that&rsquo;s it, because it&rsquo;s done via a &lt;form&gt; submission instead of an XHR request.</span></p><p class="c1 c2"><span class="c3"></span></p><h3 class="c0" id="h.f4z0szqfk5hu"><span class="c9 c4">No External Identity Providers (Google, Github, Microsoft)</span></h3><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">I&rsquo;ve been in situations like this many times. First, the product team says, &ldquo;Let&rsquo;s implement email and password.&rdquo; So you do it, everything works &mdash; great success! But suddenly, they want to add an external identity provider, like Google or GitHub authentication.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Now real fun starts.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">The only good way to do it is on the server side. It can be done on the client as well, but then it will be hard, or sometimes impossible, to validate a third party identity token from the backend.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Now, to do it on server side - you need to implement Authorization Code grant from your Authorization Server (your backend) to Identity provider (Google). With a very tricky implementation to not lose the request:</span></p><p class="c1"><span><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 344.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 344.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">This flow works, as it is in prod right now, but it is very insecure and looks like a big &ldquo;hack&rdquo; or &ldquo;workaround&rdquo;. It is so complicated, because the client has a different &ldquo;origin&rdquo; or domain where it is hosted.</span></p><p class="c1 c2"><span class="c3"></span></p><h3 class="c0" id="h.m2xbl5moh5x5"><span class="c9 c4">Single Sign On is not possible</span></h3><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">Nativelly, OAuth or OIDC implementations are SSO by default, cause you can connect clients in 1 hour, and you have auth with all needed providers, and features like MFA ready in production.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">For the custom Password Grant type - you need to implement it for every new client (login page, token logic, etc).</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 396.00px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 396.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c0" id="h.d49gfrr6v7io"><span class="c4 c9">Does not support Multi Factor Auth (MFA)</span></h3><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>Here, I need to point out that this flow does not support MFA out of the box with Authorization Servers like Microsoft Entra, Google Auth, etc. However, </span><span class="c4">you can</span><span class="c3">&nbsp;implement it yourself.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">The problem is that it&rsquo;s not standardized, which introduces multiple security issues &mdash; you&#39;d essentially be reinventing the wheel. Also, it involves communication between the client and the Authorization Server, whereas in a proper OAuth implementation, MFA is handled entirely on the Authorization Server&rsquo;s side.</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span>From </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://oauth.net/2/grant-types/password/&amp;sa=D&amp;source=editors&amp;ust=1744983134517687&amp;usg=AOvVaw36i-hGwm6wWyORDZbQYi8i">oauth.net</a></span><span>:</span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 242.67px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 242.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span>And from </span><span class="c7"><a class="c5" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth-ropc&amp;sa=D&amp;source=editors&amp;ust=1744983134517915&amp;usg=AOvVaw0Ja4GzyDv5AtTgss9OI_Q8">MSDN</a></span><span>:<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 392.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 392.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1 c2"><span class="c3"></span></p><h2 class="c6" id="h.etzxk1ggsmtc"><span class="c8 c4">Conclusion</span></h2><p class="c1"><span class="c3">As you can see, the Custom Password Credentials grant type has many drawbacks, starting from security and ending with scalability. </span></p><p class="c1 c2"><span class="c3"></span></p><p class="c1"><span class="c3">However, it does not mean you should go and implement OAuth protocol as it will take you some time, and it is more complex. If you plan to use multiple clients (browser, mobile), and identity providers (Google, Facebook, Github, Microsoft) - then it might be a very good idea. Nowadays there are a bunch of SaaS products for that (Clerk, Duende, OpenIddict, Auth0), that let you configure OpenId Connect in a matter of hours + ready made OAuth Client libraries.</span></p><p class="c1 c2"><span class="c3"></span></p></body></html>