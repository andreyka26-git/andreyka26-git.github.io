<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=mW_CIZvkcW1i7Mw9mVo5Pw1nGhQimsDuvOKTiJCJG5Q);ol{margin:0;padding:0}table td,table th{padding:0}.c0{background-color:#282828;padding-top:0pt;padding-bottom:0pt;line-height:1.35;orphans:2;widows:2;text-align:left;height:11pt}.c4{background-color:#282828;padding-top:0pt;padding-bottom:0pt;line-height:1.35;orphans:2;widows:2;text-align:left}.c6{color:#6a9955;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c15{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{font-size:10pt;font-family:"Courier New";color:#569cd6;font-weight:400}.c1{font-size:10pt;font-family:"Courier New";color:#b5cea8;font-weight:400}.c10{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c9{color:#000000;font-weight:400;font-size:11pt;font-family:"Ubuntu"}.c5{font-size:10pt;font-family:"Courier New";color:#d4d4d4;font-weight:400}.c14{font-size:10pt;font-family:"Courier New";color:#c586c0;font-weight:400}.c2{font-size:10pt;font-family:"Courier New";color:#9cdcfe;font-weight:400}.c12{font-size:10pt;font-family:"Courier New";color:#dcdcaa;font-weight:400}.c17{font-size:10pt;font-family:"Courier New";color:#4ec9b0;font-weight:400}.c16{color:#000000;font-size:16pt;font-family:"Ubuntu"}.c8{text-decoration:none;vertical-align:baseline;font-style:normal}.c19{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c18{color:inherit;text-decoration:inherit}.c13{height:11pt}.c11{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Ubuntu"}p{margin:0;color:#000000;font-size:11pt;font-family:"Ubuntu"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:16pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-weight:700;font-size:12pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c19 doc-content"><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.pnnof9y8weez"><span class="c8 c11 c16">Why you may want to read this note</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">As a Software Engineer at Microsoft I didn&rsquo;t do LeetCode interview questions for a long time already. Now I&rsquo;m refreshing my skills in algorithm questions and these set of articles are for myself in future and for whoever is solving it right now.<br><br>We are going to discuss the thinking process, insights, worse/better approaches, complexity analysis<br></span></p><p class="c3"><span>The list: </span><span class="c10"><a class="c18" href="https://www.google.com/url?q=https://leetcode.com/studyplan/leetcode-75/&amp;sa=D&amp;source=editors&amp;ust=1744111798579588&amp;usg=AOvVaw0F7bpH7T15J7KTxP9Poafg">LeetCode-75</a></span><span class="c9 c8">&nbsp;</span></p><p class="c3"><span>The problem: </span><span class="c10"><a class="c18" href="https://www.google.com/url?q=https://leetcode.com/problems/partition-equal-subset-sum/description/?envType%3Ddaily-question%26envId%3D2025-04-07&amp;sa=D&amp;source=editors&amp;ust=1744111798579933&amp;usg=AOvVaw1_JU1lXNjLW4BsJeWvuofF">416. Partition Equal Subset Sum</a></span></p><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.3ectljdfr2b9"><span class="c16 c8 c11">Problem</span></h2><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 381.33px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 381.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c9 c8">Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">&nbsp;</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Example 1:</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Input: nums = [1,5,11,5]</span></p><p class="c3"><span class="c9 c8">Output: true</span></p><p class="c3"><span class="c9 c8">Explanation: The array can be partitioned as [1, 5, 5] and [11].</span></p><p class="c3"><span class="c9 c8">Example 2:</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Input: nums = [1,2,3,5]</span></p><p class="c3"><span class="c9 c8">Output: false</span></p><p class="c3"><span class="c9 c8">Explanation: The array cannot be partitioned into equal sum subsets.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.syk07yg1757o"><span class="c16 c8 c11">Brute force 1 O(2^n) O(n)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Initially we can do a brute force solution. We maintain 2 sums, and try to add the current index either to the first sum or to the second. If in the end we got sums equal to each other - we return true, otherwise - false.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">len</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2 c8">length</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">firstSum</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">secondSum</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">can</span><span class="c5">&nbsp;= </span><span class="c7 c8">false</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c12">trav</span><span class="c5">(</span><span class="c1">0</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2 c8">can</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">function</span><span class="c5">&nbsp;</span><span class="c12">trav</span><span class="c5">(</span><span class="c2">ind</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">ind</span><span class="c5">&nbsp;&gt;= </span><span class="c2">len</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">firstSum</span><span class="c5">&nbsp;=== </span><span class="c2">secondSum</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">can</span><span class="c5">&nbsp;= </span><span class="c7 c8">true</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">firstSum</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c12">trav</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">firstSum</span><span class="c5">&nbsp;-= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">]</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">secondSum</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c12">trav</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">secondSum</span><span class="c5">&nbsp;-= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Runtime Complexity</span><span class="c9 c8">: O(2^n) as we are spawning 2 more function calls per function</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Space Complexity</span><span class="c9 c8">: &nbsp;O(n) as we are doing n recursive calls at 1 time at most</span></p><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.t41kx9yhqd2m"><span class="c16 c8 c11">Brute force 2 O(2^n) O(n)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">We could think about it in terms of math, and conclude that we don&rsquo;t have to maintain 2 sums. We just need to find a subset that will be equal to sum / 2, since in the end we should be having 2 sums: `sum / 2 + sum / 2 = sum`.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">len</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2 c8">length</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">sum</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">can</span><span class="c5">&nbsp;= </span><span class="c7 c8">false</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">target</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c2">target</span><span class="c5">&nbsp;/ </span><span class="c1 c8">2</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c12">trav</span><span class="c5">(</span><span class="c1">0</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2 c8">can</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">function</span><span class="c5">&nbsp;</span><span class="c12">trav</span><span class="c5">(</span><span class="c2">ind</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">ind</span><span class="c5">&nbsp;&gt;= </span><span class="c2">len</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">sum</span><span class="c5">&nbsp;=== </span><span class="c2">target</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">can</span><span class="c5">&nbsp;= </span><span class="c7 c8">true</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">sum</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c12">trav</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">sum</span><span class="c5">&nbsp;-= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">]</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c12">trav</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3"><span class="c11">Runtime Complexity</span><span class="c9 c8">: O(2^n) as we are spawning 2 more function calls per function</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Space Complexity</span><span>: &nbsp;O(n) as we are doing n recursive calls at 1 time at most</span></p><h2 class="c15" id="h.x508zdvjto67"><span class="c16 c8 c11">Brute force 3 O(2^n) O(n)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">We cannot change this problem to a Dynamic programming problem, as it maintains the state per decision tree. Instead, we should move it to parameters.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">We now should ask ourselves a question, how can we split this problem into subproblems? Keep in mind in order to use caching - we should design a function that will return a solution to the given parameters.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">In our case we can split it to the following subproblem: given index `ind`, and target sum `targetSum` &nbsp;- can we find a subset that will be equal to `targetSum`?</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">len</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2 c8">length</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">allSum</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">allSum</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">targetSum</span><span class="c5">&nbsp;= </span><span class="c2">allSum</span><span class="c5">&nbsp;/ </span><span class="c1 c8">2</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c12">sum</span><span class="c5">(</span><span class="c1">0</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">function</span><span class="c5">&nbsp;</span><span class="c12">sum</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">ind</span><span class="c5">&nbsp;=== </span><span class="c2">len</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7">false</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">targetSum</span><span class="c5">&nbsp;=== </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7 c8">true</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">targetSum</span><span class="c5">&nbsp;&lt; </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7 c8">false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">withCurr</span><span class="c5">&nbsp;= </span><span class="c12">sum</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5">&nbsp;- </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">])</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">withoutCurr</span><span class="c5">&nbsp;= </span><span class="c12">sum</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">can</span><span class="c5">&nbsp;= </span><span class="c2">withCurr</span><span class="c5">&nbsp;|| </span><span class="c2 c8">withoutCurr</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2 c8">can</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3"><span class="c9 c8">In terms of complexity it is exactly the same. But now we formed our recursive function to the state that can leverage caching, so DP.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Runtime Complexity</span><span class="c9 c8">: O(2^n) as we are spawning 2 more function calls per function</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Space Complexity</span><span class="c9 c8">: &nbsp;O(n) as we are doing n recursive calls at 1 time at most</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.f0jqhtapgsa1"><span class="c16 c8 c11">Top Down DP O(n * target) O( n * target)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Now let&rsquo;s just add memoization to previous solution</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span>```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">len</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2 c8">length</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">dp</span><span class="c5">&nbsp;= </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Array</span><span class="c5">(</span><span class="c2">len</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">allSum</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">] = </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Map</span><span class="c5 c8">()</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">allSum</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">targetSum</span><span class="c5">&nbsp;= </span><span class="c2">allSum</span><span class="c5">&nbsp;/ </span><span class="c1 c8">2</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c12">sum</span><span class="c5">(</span><span class="c1">0</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">function</span><span class="c5">&nbsp;</span><span class="c12">sum</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">ind</span><span class="c5">&nbsp;=== </span><span class="c2">len</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7">false</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">dp</span><span class="c5">[</span><span class="c2">ind</span><span class="c5">].</span><span class="c12">has</span><span class="c5">(</span><span class="c2">targetSum</span><span class="c5 c8">)) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2">dp</span><span class="c5">[</span><span class="c2">ind</span><span class="c5">].</span><span class="c12">get</span><span class="c5">(</span><span class="c2">targetSum</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">targetSum</span><span class="c5">&nbsp;=== </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7 c8">true</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">targetSum</span><span class="c5">&nbsp;&lt; </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7 c8">false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">withCurr</span><span class="c5">&nbsp;= </span><span class="c12">sum</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5">&nbsp;- </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">ind</span><span class="c5 c8">])</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">withoutCurr</span><span class="c5">&nbsp;= </span><span class="c12">sum</span><span class="c5">(</span><span class="c2">ind</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5">, </span><span class="c2">targetSum</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">can</span><span class="c5">&nbsp;= </span><span class="c2">withCurr</span><span class="c5">&nbsp;|| </span><span class="c2 c8">withoutCurr</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">ind</span><span class="c5">].</span><span class="c12">set</span><span class="c5">(</span><span class="c2">targetSum</span><span class="c5">, </span><span class="c2">can</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2 c8">can</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3"><span class="c11">Runtime Complexity</span><span class="c9 c8">: O(n * target) as we are trying every index, and we might have any value as target from 0 to target</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Space Complexity</span><span>: &nbsp;O(n * target) as the size of cache</span></p><h2 class="c15" id="h.h4jsf34q6qgx"><span class="c16 c8 c11">Bottom Up DP O(n * target) O(n * target)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">sum</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c12">reduce</span><span class="c5">((</span><span class="c2">acc</span><span class="c5">, </span><span class="c2">num</span><span class="c5">) </span><span class="c7">=&gt;</span><span class="c5">&nbsp;</span><span class="c2">acc</span><span class="c5">&nbsp;+ </span><span class="c2">num</span><span class="c5">, </span><span class="c1">0</span><span class="c5 c8">);</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// If sum is odd, we can&#39;t partition into equal subsets</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">sum</span><span class="c5">&nbsp;% </span><span class="c1">2</span><span class="c5">&nbsp;!== </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7">false</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c2">sum</span><span class="c5">&nbsp;/ </span><span class="c1">2</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">n</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2">length</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// Initialize 2D DP table</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// dp[i][j] = true if we can make sum j using elements from nums[0...i]</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">dp</span><span class="c5">&nbsp;= </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Array</span><span class="c5">(</span><span class="c2">n</span><span class="c5 c8">);</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">n</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">] = </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Array</span><span class="c5">(</span><span class="c2">target</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5">).</span><span class="c12">fill</span><span class="c5">(</span><span class="c7">false</span><span class="c5 c8">);</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">][</span><span class="c1">0</span><span class="c5">] = </span><span class="c7">true</span><span class="c5">; </span><span class="c6">// Empty subset can always make sum of 0</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// Handle the first element separately</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">nums</span><span class="c5">[</span><span class="c1">0</span><span class="c5">] &lt;= </span><span class="c2">target</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c1">0</span><span class="c5">][</span><span class="c2">nums</span><span class="c5">[</span><span class="c1">0</span><span class="c5">]] = </span><span class="c7">true</span><span class="c5 c8">;</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// Fill the DP table bottom-up</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">1</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">n</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">j</span><span class="c5">&nbsp;= </span><span class="c1">1</span><span class="c5">; </span><span class="c2">j</span><span class="c5">&nbsp;&lt;= </span><span class="c2">target</span><span class="c5">; </span><span class="c2">j</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6">// Either include the current element or exclude it</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">j</span><span class="c5">&nbsp;&lt; </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">][</span><span class="c2">j</span><span class="c5">] = </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">-</span><span class="c1">1</span><span class="c5">][</span><span class="c2">j</span><span class="c5">]; &nbsp;</span><span class="c6">// Can&#39;t include current element</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="c14">else</span><span class="c5 c8">&nbsp;{</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">][</span><span class="c2">j</span><span class="c5">] = </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">-</span><span class="c1">1</span><span class="c5">][</span><span class="c2">j</span><span class="c5">] || </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">i</span><span class="c5">-</span><span class="c1">1</span><span class="c5">][</span><span class="c2">j</span><span class="c5">&nbsp;- </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]];</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2">dp</span><span class="c5">[</span><span class="c2">n</span><span class="c5">-</span><span class="c1">1</span><span class="c5">][</span><span class="c2">target</span><span class="c5 c8">];</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3"><span class="c11">Runtime Complexity</span><span class="c9 c8">: O(n * target) as we are trying every index, and we might have any value as target from 0 to target</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Space Complexity</span><span class="c9 c8">: &nbsp;O(n * target) as the size of cache</span></p><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.4wlw26hlzma1"><span class="c16 c8 c11">Efficient Solution O(n *target) O(n *target)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Another optimization would be to calculate all possible sums that we can get and put all of them into a set. Then just try to find the target in the set.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Besides that, we can improve performance by using math. If our sum is not divisible by 2 - then we return false straight away.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">len</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2 c8">length</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">target</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">target</span><span class="c5">&nbsp;% </span><span class="c1">2</span><span class="c5">&nbsp;!== </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7 c8">false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c2">target</span><span class="c5">&nbsp;/ </span><span class="c1">2</span><span class="c5 c8">&nbsp; &nbsp; </span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">set</span><span class="c5">&nbsp;= </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Set</span><span class="c5">([</span><span class="c1">0</span><span class="c5 c8">])</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">newSet</span><span class="c5">&nbsp;= </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Set</span><span class="c5">(</span><span class="c2">set</span><span class="c5 c8">)</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">value</span><span class="c5">&nbsp;</span><span class="c7">of</span><span class="c5">&nbsp;</span><span class="c2">set</span><span class="c5">.</span><span class="c12">values</span><span class="c5 c8">()) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">newVal</span><span class="c5">&nbsp;= </span><span class="c2">value</span><span class="c5">&nbsp;+ </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">newVal</span><span class="c5">&nbsp;&lt;= </span><span class="c2">target</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">newSet</span><span class="c5">.</span><span class="c12">add</span><span class="c5">(</span><span class="c2">newVal</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">set</span><span class="c5">&nbsp;= </span><span class="c2 c8">newSet</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2">set</span><span class="c5">.</span><span class="c12">has</span><span class="c5">(</span><span class="c2">target</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3"><span class="c11">Runtime Complexity</span><span class="c9 c8">: O(n * target) as we are trying every index, and we might have any value as target from 0 to target</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c11">Space Complexity</span><span class="c9 c8">: &nbsp;O(n * target) as the size of cache</span></p><p class="c3 c13"><span class="c9 c8"></span></p><h2 class="c15" id="h.aher7vzdbah5"><span class="c16 c8 c11">Knapsack DP O(target) O(target)</span></h2><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">There is a knapsack solution to this as well, as optimization to the solution above</span></p><p class="c3"><span class="c9 c8">So we are keeping our DP array, which means the following</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">If dp[i] == true &nbsp;- then &nbsp;sum `i` can be made in this subset.</span></p><p class="c3"><span class="c9 c8">If dp[i] == false - then we cannot make sum `i` out of this subset.</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```js</span></p><p class="c4"><span class="c7">var</span><span class="c5">&nbsp;</span><span class="c12">canPartition</span><span class="c5">&nbsp;= </span><span class="c7">function</span><span class="c5">(</span><span class="c2">nums</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">len</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">.</span><span class="c2 c8">length</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c1 c8">0</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">target</span><span class="c5">&nbsp;+= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">if</span><span class="c5">&nbsp;(</span><span class="c2">target</span><span class="c5">&nbsp;% </span><span class="c1">2</span><span class="c5">&nbsp;!== </span><span class="c1">0</span><span class="c5 c8">) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c7 c8">false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c2">target</span><span class="c5">&nbsp;= </span><span class="c2">target</span><span class="c5">&nbsp;/ </span><span class="c1 c8">2</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">dp</span><span class="c5">&nbsp;= </span><span class="c7">new</span><span class="c5">&nbsp;</span><span class="c17">Array</span><span class="c5">(</span><span class="c2">target</span><span class="c5">&nbsp;+ </span><span class="c1">1</span><span class="c5">).</span><span class="c12">fill</span><span class="c5">(</span><span class="c7">false</span><span class="c5 c8">)</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c1">0</span><span class="c5">] = </span><span class="c7 c8">true</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">i</span><span class="c5">&nbsp;= </span><span class="c1">0</span><span class="c5">; </span><span class="c2">i</span><span class="c5">&nbsp;&lt; </span><span class="c2">len</span><span class="c5">; </span><span class="c2">i</span><span class="c5 c8">++) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">curr</span><span class="c5">&nbsp;= </span><span class="c2">nums</span><span class="c5">[</span><span class="c2">i</span><span class="c5 c8">]</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">cand</span><span class="c5">&nbsp;= </span><span class="c2">target</span><span class="c5">; </span><span class="c2">cand</span><span class="c5">&nbsp;&gt;= </span><span class="c2">curr</span><span class="c5">; </span><span class="c2">cand</span><span class="c5 c8">--) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">cand</span><span class="c5">] = </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">cand</span><span class="c5">] || </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">cand</span><span class="c5">&nbsp;- </span><span class="c2">curr</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c14">return</span><span class="c5">&nbsp;</span><span class="c2">dp</span><span class="c5">[</span><span class="c2">target</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5">};</span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">Keep in mind that the order from target to `curr` is very important here, to omit duplicates: `let cand = target; cand &gt;= curr; cand--`, for example, take a look at this one:</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```</span></p><p class="c4"><span class="c2">dp</span><span class="c5">&nbsp;= [</span><span class="c7">true</span><span class="c5">, </span><span class="c7">false</span><span class="c5">, </span><span class="c7">false</span><span class="c5">, </span><span class="c7">false</span><span class="c5">, </span><span class="c7">false</span><span class="c5">, </span><span class="c7">false</span><span class="c5">, </span><span class="c7">false</span><span class="c5">] &nbsp;</span><span class="c6">// Initialize dp</span></p><p class="c0"><span class="c6"></span></p><p class="c4"><span class="c2 c8">nums = [3]</span></p><p class="c4"><span class="c2">curr</span><span class="c5">&nbsp;= </span><span class="c1 c8">3</span></p><p class="c0"><span class="c5 c8"></span></p><p class="c4"><span class="c6">// Iterate from target to curr (backward)</span></p><p class="c4"><span class="c14">for</span><span class="c5">&nbsp;(</span><span class="c7">let</span><span class="c5">&nbsp;</span><span class="c2">cand</span><span class="c5">&nbsp;= </span><span class="c1">6</span><span class="c5">; </span><span class="c2">cand</span><span class="c5">&nbsp;&gt;= </span><span class="c1">3</span><span class="c5">; </span><span class="c2">cand</span><span class="c5 c8">--) {</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">cand</span><span class="c5">] = </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">cand</span><span class="c5">] || </span><span class="c2">dp</span><span class="c5">[</span><span class="c2">cand</span><span class="c5">&nbsp;- </span><span class="c2">curr</span><span class="c5 c8">]</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// When cand = 6:</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// dp[6] = false || dp[3] = false || false = false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// When cand = 5:</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// dp[5] = false || dp[2] = false || false = false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// When cand = 4:</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// dp[4] = false || dp[1] = false || false = false</span></p><p class="c4"><span class="c5 c8">&nbsp; &nbsp;</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// When cand = 3:</span></p><p class="c4"><span class="c5">&nbsp; &nbsp; </span><span class="c6">// dp[3] = false || dp[0] = false || true = true</span></p><p class="c4"><span class="c5 c8">}</span></p><p class="c4"><span class="c6">// Final dp = [true, false, false, true, false, false, false]</span></p><p class="c3 c13"><span class="c9 c8"></span></p><p class="c3"><span class="c9 c8">```</span></p></body></html>