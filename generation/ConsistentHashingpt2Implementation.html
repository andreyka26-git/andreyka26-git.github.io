<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=mW_CIZvkcW1i7Mw9mVo5Pw1nGhQimsDuvOKTiJCJG5Q);ol.lst-kix_k9ps0au756yw-6.start{counter-reset:lst-ctn-kix_k9ps0au756yw-6 0}ol.lst-kix_h5fb79agmqr8-5.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-5 0}.lst-kix_k9ps0au756yw-0>li{counter-increment:lst-ctn-kix_k9ps0au756yw-0}ol.lst-kix_lvu5b4az3ex-7.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-7 0}ol.lst-kix_h5fb79agmqr8-8.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-8 0}.lst-kix_k9ps0au756yw-1>li{counter-increment:lst-ctn-kix_k9ps0au756yw-1}ol.lst-kix_h5fb79agmqr8-2.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-2 0}.lst-kix_h5fb79agmqr8-1>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-1}.lst-kix_lvu5b4az3ex-1>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-1}.lst-kix_h5fb79agmqr8-2>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-2}.lst-kix_k9ps0au756yw-2>li{counter-increment:lst-ctn-kix_k9ps0au756yw-2}ol.lst-kix_k9ps0au756yw-3.start{counter-reset:lst-ctn-kix_k9ps0au756yw-3 0}ol.lst-kix_k9ps0au756yw-0.start{counter-reset:lst-ctn-kix_k9ps0au756yw-0 0}.lst-kix_k9ps0au756yw-3>li{counter-increment:lst-ctn-kix_k9ps0au756yw-3}.lst-kix_h5fb79agmqr8-8>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-8,lower-roman) ". "}ol.lst-kix_k9ps0au756yw-1.start{counter-reset:lst-ctn-kix_k9ps0au756yw-1 0}ol.lst-kix_k9ps0au756yw-4{list-style-type:none}.lst-kix_k9ps0au756yw-7>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-7,lower-latin) ". "}ol.lst-kix_k9ps0au756yw-5{list-style-type:none}ol.lst-kix_h5fb79agmqr8-3.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-3 0}ol.lst-kix_k9ps0au756yw-6{list-style-type:none}ol.lst-kix_k9ps0au756yw-7{list-style-type:none}.lst-kix_h5fb79agmqr8-4>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-4,lower-latin) ". "}ol.lst-kix_k9ps0au756yw-8{list-style-type:none}.lst-kix_k9ps0au756yw-8>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-8,lower-roman) ". "}.lst-kix_h5fb79agmqr8-3>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-3,decimal) ". "}.lst-kix_k9ps0au756yw-3>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-3,decimal) ". "}.lst-kix_k9ps0au756yw-1>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-1,lower-latin) ". "}.lst-kix_k9ps0au756yw-5>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-5,lower-roman) ". "}.lst-kix_k9ps0au756yw-2>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-2,lower-roman) ". "}.lst-kix_k9ps0au756yw-6>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-6,decimal) ". "}.lst-kix_h5fb79agmqr8-5>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-5,lower-roman) ". "}.lst-kix_h5fb79agmqr8-6>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-6,decimal) ". "}.lst-kix_k9ps0au756yw-4>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-4,lower-latin) ". "}ol.lst-kix_lvu5b4az3ex-5.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-5 0}.lst-kix_h5fb79agmqr8-7>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-7,lower-latin) ". "}ol.lst-kix_h5fb79agmqr8-4.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-4 0}ol.lst-kix_k9ps0au756yw-2.start{counter-reset:lst-ctn-kix_k9ps0au756yw-2 0}.lst-kix_k9ps0au756yw-0>li:before{content:"" counter(lst-ctn-kix_k9ps0au756yw-0,decimal) ". "}.lst-kix_h5fb79agmqr8-0>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-0}.lst-kix_h5fb79agmqr8-0>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-0,decimal) ". "}.lst-kix_h5fb79agmqr8-2>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-2,lower-roman) ". "}.lst-kix_h5fb79agmqr8-6>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-6}ol.lst-kix_k9ps0au756yw-0{list-style-type:none}ol.lst-kix_k9ps0au756yw-1{list-style-type:none}ol.lst-kix_lvu5b4az3ex-4.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-4 0}ol.lst-kix_k9ps0au756yw-2{list-style-type:none}.lst-kix_h5fb79agmqr8-3>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-3}ol.lst-kix_k9ps0au756yw-3{list-style-type:none}.lst-kix_h5fb79agmqr8-1>li:before{content:"" counter(lst-ctn-kix_h5fb79agmqr8-1,lower-latin) ". "}ol.lst-kix_k9ps0au756yw-8.start{counter-reset:lst-ctn-kix_k9ps0au756yw-8 0}.lst-kix_lvu5b4az3ex-0>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-0}.lst-kix_lvu5b4az3ex-6>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-6}.lst-kix_k9ps0au756yw-6>li{counter-increment:lst-ctn-kix_k9ps0au756yw-6}.lst-kix_lvu5b4az3ex-3>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-3}.lst-kix_lvu5b4az3ex-5>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-5}.lst-kix_h5fb79agmqr8-7>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-7}ol.lst-kix_lvu5b4az3ex-0.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-0 0}.lst-kix_lvu5b4az3ex-4>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-4}.lst-kix_h5fb79agmqr8-8>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-8}.lst-kix_k9ps0au756yw-5>li{counter-increment:lst-ctn-kix_k9ps0au756yw-5}ol.lst-kix_lvu5b4az3ex-3.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-3 0}ol.lst-kix_lvu5b4az3ex-7{list-style-type:none}ol.lst-kix_lvu5b4az3ex-6{list-style-type:none}ol.lst-kix_lvu5b4az3ex-8{list-style-type:none}ol.lst-kix_k9ps0au756yw-7.start{counter-reset:lst-ctn-kix_k9ps0au756yw-7 0}.lst-kix_k9ps0au756yw-7>li{counter-increment:lst-ctn-kix_k9ps0au756yw-7}ol.lst-kix_lvu5b4az3ex-3{list-style-type:none}ol.lst-kix_lvu5b4az3ex-2{list-style-type:none}ol.lst-kix_lvu5b4az3ex-5{list-style-type:none}.lst-kix_lvu5b4az3ex-7>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-7}ol.lst-kix_lvu5b4az3ex-4{list-style-type:none}.lst-kix_h5fb79agmqr8-5>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-5}.lst-kix_lvu5b4az3ex-5>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-5,lower-roman) ". "}.lst-kix_lvu5b4az3ex-6>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-6,decimal) ". "}ol.lst-kix_lvu5b4az3ex-6.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-6 0}.lst-kix_lvu5b4az3ex-7>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-7,lower-latin) ". "}ol.lst-kix_h5fb79agmqr8-6.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-6 0}.lst-kix_lvu5b4az3ex-8>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-8,lower-roman) ". "}ol.lst-kix_lvu5b4az3ex-2.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-2 0}ol.lst-kix_h5fb79agmqr8-2{list-style-type:none}ol.lst-kix_h5fb79agmqr8-3{list-style-type:none}ol.lst-kix_h5fb79agmqr8-0{list-style-type:none}ol.lst-kix_h5fb79agmqr8-0.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-0 0}ol.lst-kix_h5fb79agmqr8-1{list-style-type:none}ol.lst-kix_h5fb79agmqr8-6{list-style-type:none}ol.lst-kix_h5fb79agmqr8-7{list-style-type:none}ol.lst-kix_h5fb79agmqr8-4{list-style-type:none}ol.lst-kix_h5fb79agmqr8-5{list-style-type:none}.lst-kix_lvu5b4az3ex-2>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-2}.lst-kix_lvu5b4az3ex-4>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-4,lower-latin) ". "}ol.lst-kix_h5fb79agmqr8-8{list-style-type:none}.lst-kix_lvu5b4az3ex-3>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-3,decimal) ". "}ol.lst-kix_lvu5b4az3ex-1{list-style-type:none}ol.lst-kix_lvu5b4az3ex-0{list-style-type:none}ol.lst-kix_h5fb79agmqr8-7.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-7 0}.lst-kix_k9ps0au756yw-8>li{counter-increment:lst-ctn-kix_k9ps0au756yw-8}.lst-kix_lvu5b4az3ex-2>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-2,lower-roman) ". "}.lst-kix_k9ps0au756yw-4>li{counter-increment:lst-ctn-kix_k9ps0au756yw-4}.lst-kix_lvu5b4az3ex-8>li{counter-increment:lst-ctn-kix_lvu5b4az3ex-8}.lst-kix_lvu5b4az3ex-1>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-1,lower-latin) ". "}.lst-kix_h5fb79agmqr8-4>li{counter-increment:lst-ctn-kix_h5fb79agmqr8-4}ol.lst-kix_k9ps0au756yw-4.start{counter-reset:lst-ctn-kix_k9ps0au756yw-4 0}.lst-kix_lvu5b4az3ex-0>li:before{content:"" counter(lst-ctn-kix_lvu5b4az3ex-0,decimal) ". "}ol.lst-kix_lvu5b4az3ex-1.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-1 0}ol.lst-kix_lvu5b4az3ex-8.start{counter-reset:lst-ctn-kix_lvu5b4az3ex-8 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ol.lst-kix_k9ps0au756yw-5.start{counter-reset:lst-ctn-kix_k9ps0au756yw-5 0}ol.lst-kix_h5fb79agmqr8-1.start{counter-reset:lst-ctn-kix_h5fb79agmqr8-1 0}ol{margin:0;padding:0}table td,table th{padding:0}.c6{color:#666666;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Ubuntu";font-style:normal}.c12{color:#434343;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Ubuntu";font-style:normal}.c7{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Ubuntu";font-style:normal}.c5{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c13{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c9{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Ubuntu";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c8{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;font-weight:700;text-decoration:underline}.c3{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c14{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c4{margin-left:36pt;padding-left:0pt}.c11{padding:0;margin:0}.c10{color:inherit;text-decoration:inherit}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Ubuntu"}p{margin:0;color:#000000;font-size:11pt;font-family:"Ubuntu"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:16pt;padding-bottom:6pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-weight:700;font-size:12pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Ubuntu";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c14 doc-content"><h2 class="c9" id="h.zgwkk8j959r8"><span class="c7">Why you may want to read this article</span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">In this article, `we will implement a Consistent Hashing` algorithm along with a simple `Distributed Cache`. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>Our implemented Distributed Cache will use </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Partition_(database)&amp;sa=D&amp;source=editors&amp;ust=1740509661978193&amp;usg=AOvVaw1eBwFf6LaCx-0yCZ-VGARo">Partitioning</a></span><span class="c0">&nbsp;[2] for the distribution of the load. It will be able to rebalance automatically (dynamic rebalancing) when some node is overloaded (memory-wise) using the `Consistent Hashing` technique. On top of that, we will implement the creation of a new Partition Node during runtime.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We will use .NET for this, but actually, you can implement it in any language that supports HTTP request handling and operating system process creation.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>Highly recommended to read the </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://andreyka26.com/consistent-hashing-pt1-theory&amp;sa=D&amp;source=editors&amp;ust=1740509661978544&amp;usg=AOvVaw2er_idkncRg-9g_OADgXKd">previous article</a></span><span class="c0">&nbsp;about the `Consistent Hashing` algorithm, different approaches and representations of this technique, and an overview of the first Computer Science paper by David Karger [1], which explained the algorithm.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>Full implementation (Source Code) of Distributed Cache using `Consistent Hashing` algorithm you could find in </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/tree/main/ConsistentHashing&amp;sa=D&amp;source=editors&amp;ust=1740509661978752&amp;usg=AOvVaw1tKuD503wsgFUc065iPfbX">my Github repository</a></span><span class="c0">.</span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.d02cbv74bfl4"><span class="c7">Distributed Cache Architecture</span></h2><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>In our implementation, we will use </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Partition_(database)&amp;sa=D&amp;source=editors&amp;ust=1740509661979017&amp;usg=AOvVaw3qVCN1iS9KM-5jKQZIEfgz">Partitioning</a></span><span class="c0">&nbsp;[2]. It is a technique that splits data among machines so that each machine is responsible for handling a subset of data. Particularly, we will use `Partitioning by Hash of Key` [3].</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.p69xaqedkjkb"><span class="c12">Request Routing</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The first decision about the partitioning strategy we should make - is to decide about Request Routing. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Since we are using `Consistent Hashing`, the Request Routing Service should keep an up-to-date `Hashing Ring` based on which it will decide the correct node for the request.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">There are 3 main approaches to request routing when we talk about `Partitioning` [4]:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 310.67px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 310.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`1.` Node routing. In this approach, the Client sends a request to a random node. Each node knows about other nodes and will redirect the request to the necessary node.</span></p><p class="c2"><span class="c0">I don&rsquo;t prefer this approach, because then each node needs to keep Hashing Ring up-to-date. Any change in the cluster will end up in updating each node.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>`2.` </span><span class="c8">Load balancer routing</span><span class="c0">. In this approach, we have a few Load Balancers (otherwise it will be a single point of failure). The client calls any of our Load Balancers. They keep Hashing Ring and route the request to the particular node. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It is expected to have not that many Load Balancers. Load balancers are stateless (to some point), meaning that new Load Balancers just need to call some other Load Balancer or Master and they can start serving data.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">On top of that, it is better for us in terms of hashing ring updates, because, we even can do it synchronously by blocking the entire Load Balancer node, cause all clients can go to another Load Balancer meanwhile.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`3.` Client routing. In this approach, the client knows how to map the hash of the key to a particular node. It will not be easy to implement, because we would need the mechanism to notify the client about Hash Ring change. For that we need to implement consistent polling, or some push notifications mechanism.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.1obyc9xegbbs"><span class="c12">High-Level Architecture</span></h3><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>According to </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://www.amazon.com/Software-Architecture-Practice-3rd-Engineering/dp/0321815734&amp;sa=D&amp;source=editors&amp;ust=1740509661980539&amp;usg=AOvVaw0JVAT8RRNnSvGC2549XDqK">Software Architecture in Practice </a></span><span class="c0">book Our Component-and-connector [5] (in runtime) architecture looks like that:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 516.00px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 516.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><h4 class="c13" id="h.pfw5nfbe0466"><span class="c6">How it is in MongoDb</span></h4><p class="c1"><span class="c0"></span></p><p class="c2"><span>Our architecture is really similar to </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://www.mongodb.com/&amp;sa=D&amp;source=editors&amp;ust=1740509661980998&amp;usg=AOvVaw3H1P7iOvxdlMmjallt3pvL">MongoDb</a></span><span class="c0">&nbsp;architecture [6]:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 350.67px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">In our case `Shard = ChildNode, Mongos = Load Balancer, Config Server = Master Service`</span></p><p class="c1"><span class="c0"></span></p><h4 class="c13" id="h.847aclee1r8g"><span class="c6">Client</span></h4><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">There might be multiple clients. They know only about `Load Balancers` and communicate only with them. `Clients` could be anything that can use HTTP protocol.</span></p><p class="c1"><span class="c0"></span></p><h4 class="c13" id="h.h1g7w03tvpid"><span class="c6">Child Node</span></h4><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Child Node is exactly one partition. In terms of Consistent Hashing, it is just one node placed into Hashing Ring that serves get/set functionality for distributed cache or partitioned database. Actually, it represents multiple partitions by Virtual Node approach But for simplicity think about it as a separate Partition.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Ideally, Child Node should know nothing about other components. In our case, it needs to let Master know it is overloaded to start rebalancing. It might be some message broker. I implemented it in a simpler way - Child Node just sends request to Master, and Master starts rebalancing straight away.</span></p><p class="c1"><span class="c0"></span></p><h4 class="c13" id="h.q6iygc8g0vce"><span class="c6">Load Balancer</span></h4><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">For our functional requirements single `Load Balancer` &nbsp;would be enough, although, this would be Single-Point-Of-Failure in that case. Therefore we keep multiple `Load Balancers` at the same time. `Load balancer` directs request from `Client` to `ChildNode`. Load Balancer knows about every `ChildNode`.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Keep in mind that this knowledge has `eventual consistency` property, so 2 different `Load Balancers` might have different knowledge about all `ChildNodes`, but eventually, this knowledge will be the same.</span></p><p class="c1"><span class="c0"></span></p><h4 class="c13" id="h.degz73ncbi1x"><span class="c6">Master</span></h4><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Master knows about Child Nodes and Load Balancers. It is responsible for rebalancing, and managing all the Nodes, for example, it can spin a new Child Node or a new Load Balancer.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We have only a single Master in our Cluster. The reason is simple, we don&rsquo;t want 2 Masters to start rebalancing the same node, because rebalancing is a long operation. Even though it is Single-Point-Of-Failure, we accept it. It is not critical for our functional requirements: &nbsp;get/set operations (Load Balancer and Child Node are). It is essential for rebalancing, and it actually can wait to be fixed.<br><br>It is possible to make it reliable by replication, but then we will end up implementing Consensus algorithm to promote some node to Master role in case of failures, or implementing another fancy algorithm to address consistency and concurrency issues.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>Note, it seems that `in MongoDb Config Server (alternative of our Master) is Single-Point-Of-Failure for write operations` as well. </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://www.mongodb.com/docs/manual/core/sharded-cluster-config-servers/%23config-server-availability&amp;sa=D&amp;source=editors&amp;ust=1740509661982821&amp;usg=AOvVaw1K8r0fzZ8FEog66qovHN61">Here</a></span><span class="c0">&nbsp;it is explained [6]:</span></p><p class="c2"><span><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 269.33px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 269.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0"><br><br></span></p><p class="c2"><span class="c0">You can see, that in case Master Config Server (leader/primary) is lost, you also cannot do rebalancing in MongoDb.<br>As I said, in such case you need to implement Leader Election algorithm which is pretty hard. </span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.59t4dfv48b5"><span class="c7">Implementation</span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span>All the source code you could find in </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/tree/main/ConsistentHashing&amp;sa=D&amp;source=editors&amp;ust=1740509661983287&amp;usg=AOvVaw2OAEFG7L0WTTSqchn06Jyz">my GitHub repository</a></span><span class="c0">.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>Before we start digging into details, referencing </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://andreyka26.com/consistent-hashing-pt1-theory%23terminology--prerequisites&amp;sa=D&amp;source=editors&amp;ust=1740509661983496&amp;usg=AOvVaw0a0KWzhmCn1OsbZ0_awCGW">my previous article</a></span><span class="c0">, I need to put definitions.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We have 2 concepts: `Physical Node` and `Virtual Node`. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`Physical Node` is supposed to be a different machine to leverage partitioning. Otherwise, if we put an additional Node to the same Server it will not give us any boost in memory or CPU. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`Virtual Node` is the node that is used in Hashing Ring. There might be multiple Virtual Nodes on the same machine. It makes sense because sometimes one server is more powerful than another one. On top of that it is sometimes easier to move Virtual node between the Physical Nodes. Virtual Node gives you flexibility for the initial setup of your cluster. You might choose to set up 100 nodes on 5 servers. And then you might just spread Virtual Nodes to new Physical Node. Only after some time, you will end up splitting Virtual Nodes itself.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Our Distributed Cache will keep 1:1 mapping between `Physical Node` and `Virtual Node`, so 1 Physical Node (Child Node) must have 1 Virtual Node. It is done like that for demonstration purposes.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">In my implementation, `Child Node` conceptually should be considered a `Physical Node`, and should be hosted as a single API on a single server. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">On top of that, we assume, that the key and value should be strings. If you need objects - use serialization. The key hash in our case is int32.</span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.uhnavtkxynz"><span class="c7">Common Services</span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">There are some common services, that are used by different Nodes in the cluster.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.so8hptljlldu"><span class="c12">VirtualNode</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/NodeManagement/VirtualNode.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661984573&amp;usg=AOvVaw3WLKVqlK6SuZS1MZx_CZne">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`VirtualNode` is a class (actually record in .NET) that represents one Virtual Node that we are using in our Hashing Ring. It only has Position and MaxItems possible for that Virtual Node.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">// we consider specific ring position of the virtual node as unique identifier</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; // meaning no 2 virtupal nodes can point to exactly same ring position (radian or degree)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; public record VirtualNode(uint RingPosition, int MaxItemsCount);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```</span></p><h3 class="c5" id="h.r89gq560y1i0"><span class="c12">PhysicalNode</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/NodeManagement/PhysicalNode.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661985335&amp;usg=AOvVaw0ouYmuFPq2nLxTZqsvOzDe">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`PhysicalNode` represents a particular machine or server. In our case, it represents one instance of Child Node that could contain multiple Virtual Nodes, or one instance of Load Balancer.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public record PhysicalNode(Uri Location);</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It only has Url to particular Child Node or Load Balancer instance.</span></p><h3 class="c5" id="h.n7wejv1y8pek"><span class="c12">IHashingRing</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/HashingRing.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661986091&amp;usg=AOvVaw0rBU0ZT3FV66y1NUhr_P8u">Source code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`HashingRing` is the main service for Consistent Hashing. It manages nodes in the circle providing some useful API: adding nodes, removing nodes, and searching nodes by the key hash.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public class HashingRing : IHashingRing</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly IHashService _hashService;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly SortedList&lt;uint, VirtualNode&gt; _virtualNodes = new SortedList&lt;uint, VirtualNode&gt;();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public HashingRing(IHashService hashService)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _hashService = hashService;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public uint MaxValue =&gt; _hashService.MaxHashValue;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //TODO thread safety if add/remove/get in parallel</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void RemoveVirtualNode(uint nodePosition)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _virtualNodes.Remove(nodePosition);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; //TODO thread safety if add/remove/get in parallel</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public void AddVirtualNode(VirtualNode virtualNode)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _virtualNodes.Add(virtualNode.RingPosition, virtualNode);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public VirtualNode GetVirtualNodeForHash(uint keyPosition)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var sortedNodePositions = _virtualNodes.Keys;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var nodePosition = BinarySearchRightMostNode(sortedNodePositions, keyPosition);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var node = _virtualNodes[nodePosition];</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return node;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public uint BinarySearchRightMostNode(IList&lt;uint&gt; nodePositions, uint keyPosition)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // in case keyPosition is bigger than MaxValue (if we consider to use real 360 degree circle or any other scale)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // we should adjust it to max value of ring</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyPosition = keyPosition % MaxValue;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var start = 0;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var end = nodePositions.Count - 1;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; while (start != end)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var mid = ((end - start) / 2) + start;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (keyPosition &lt;= nodePositions[mid])</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = mid;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = mid + 1;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var nodePosition = nodePositions[start];</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // if your key is after node but before MaxHashValue - we return first node (because it is hash circle)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (keyPosition &gt; nodePosition)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nodePositions[0];</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return nodePosition;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>We keep all the nodes in </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2?view%3Dnet-7.0&amp;sa=D&amp;source=editors&amp;ust=1740509661989962&amp;usg=AOvVaw2kIcGeNl2C7eQVwWeP92ox">SortedList</a></span><span class="c0">. As I understood from the source code it provides O (log N) complexity mostly. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Canonically you would need Binary Search Tree here, which gives you O(log n) for adding, removing, and searching as well. To ensure complexity you might use some balanced trees, e.g. red-black tree.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">And then we provide the necessary API using this tree or in our case SortedList.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.aawn2cws7cyq"><span>I</span><span class="c12">ChildNodeManager</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/NodeManagement/ChildNodeManager.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661990425&amp;usg=AOvVaw0UQ8lu2fwsEDaLQz7VMXPD">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`ChildNodeManager` is responsible for mapping between Physical and Virtual Nodes. It is used by Master and Load Balancer for managing all Child Nodes and how a particular Virtual Node is mapped to Child Node and vice versa. On top of that, Hashing Ring manipulation happens through this service, because it aggregates Hashing Ring.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It has 2 dictionaries along with Hashing Ring.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">private readonly Dictionary&lt;VirtualNode, PhysicalNode&gt; _virtualToPhysicalMapping = new Dictionary&lt;VirtualNode, PhysicalNode&gt;();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; // uint is a ring position, we agreed that it is unique identifier of the virtual node.</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly Dictionary&lt;PhysicalNode, Dictionary&lt;uint, VirtualNode&gt;&gt; _physicalToVirtualMapping = new Dictionary&lt;PhysicalNode, Dictionary&lt;uint, VirtualNode&gt;&gt;();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly IHashingRing _hashingRing;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public ChildNodeManager(IHashingRing hashingRing)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _hashingRing = hashingRing;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span>```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">This is sample method that adds Virtual Node to Physical Node (Child Node):</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public void AddVirtualNode(VirtualNode virtualNode, PhysicalNode toPhysicalNode)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _virtualToPhysicalMapping[virtualNode] = toPhysicalNode;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!_physicalToVirtualMapping.ContainsKey(toPhysicalNode))</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AddPhysicalNode(toPhysicalNode);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _physicalToVirtualMapping[toPhysicalNode][virtualNode.RingPosition] = virtualNode;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _hashingRing.AddVirtualNode(virtualNode);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.scs8fsy23pzx"><span>IPhysicalNodeProvider</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/NodeManagement/PhysicalNodeProvider.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661993111&amp;usg=AOvVaw2grXgaWOglo4UF51W7vxhQ">Source code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`PhysicalNodeProvider` is responsible for spinning new Physical Nodes (Child Nodes) for rebalancing. Ideally, it should be responsible for getting down Physical Nodes as well, when we drop unnecessary nodes from the Hashing Ring.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The good approach here would be to dockerize all the Modules (Child Node, Load Balancer, Master), put them into one network, and use Kubernetes with Kubernetes .NET SDK that will start a new instance in the Kubernetes cluster.<br><br>I think it would be possible, but it requires a lot of work - so let me know on social media if you are interested in it - we can do that.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Instead of that - I chose an easier but more hacky and bad approach: I am starting a new .NET process with a specific port, using built binaries on a local machine. I&rsquo;m starting Load Balancer and Child Node that way. But this is only for demonstration purposes.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public async Task&lt;PhysicalNode&gt; CreateNewPhysicalNodeAsync(string assemblyPath, int? port = default, CancellationToken cancellationToken = default)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!port.HasValue)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port = ++_currentAvailablePort;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_currentAvailablePort &gt; port)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArgumentException($&quot;Port should be monotonically increasing, set something above {_currentAvailablePort}&quot;);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _currentAvailablePort = port.Value + 1;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var url = $&quot;https://localhost:{port}&quot;;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var node = new PhysicalNode(new Uri(url));</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (_processes.ContainsKey(node))</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new ArgumentException($&quot;this port is occupied already&quot;);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var args = $&quot;--urls={url}&quot;;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var process = new Process();</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.StartInfo.FileName = assemblyPath;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.StartInfo.Arguments = args;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process.Start();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await Task.Delay(2 * 1000);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _processes.Add(node, process);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return node;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">This is the method that creates a new .NET process that will listen to the specified port. We just get the assembly path and create a new Process with specific arguments.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">For sure it is not a production code. A good approach should be Kubernetes based I think.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.dwbam08h55go"><span class="c12">IReadWriteLockService</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/Concurrency/ReadWriteLockService.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661996359&amp;usg=AOvVaw0gPNBRqhw_kFG7mO1BuSk7">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>`ReadWriteLockService` is responsible for read-write locking. It is used in `ChildNodeService` that should add and remove cache values in a threaded manner keeping 2 data structures in sync (sorted list and dictionary).<br><br>Internally it uses native </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlock?view%3Dnet-7.0&amp;sa=D&amp;source=editors&amp;ust=1740509661996610&amp;usg=AOvVaw0zy5zYNTBUF_ohn5cFiGCv">ReaderWriterLock</a></span><span class="c0">. You could read about the guarantees and synchronization techniques it provides. What is important for me - is to allow multiple readers to read at the same time, and to allow exclusive lock for writing (meaning no other read/write operation is allowed while writing).</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Note: as I know, this ReadWriteLock does not allow you to write async code (safely). But we don&rsquo;t need it in our in-memory cache.</span></p><h3 class="c5" id="h.ep6rmwgt1cpq"><span>IAsyncSerializableLockService</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/Concurrency/AsyncSerializableLockService.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661996951&amp;usg=AOvVaw3doNoNfbzGofGZnJCOxqpQ">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>`AsyncSerializableLockService` is a simple lock service that ensures 1 thread at a time is executing. It is implemented internally using </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim?view%3Dnet-7.0&amp;sa=D&amp;source=editors&amp;ust=1740509661997176&amp;usg=AOvVaw0znDVwggoUC8hd4qA-PZ2y">SemaphoreSlim </a></span><span class="c0">with `WaitAsync` that allows you to write async code inside a locked area compared to `ReadWriteLockService`.</span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.d2ontv26z3cf"><span class="c7">Child Node</span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 330.67px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 330.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`Child Node` is an HTTP service that is responsible for managing and handling one or more `Virtual Nodes` inside it. The instance of `Child Node` should be considered as `PhysicalNode`.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.7ryfq7e5fkad"><span class="c12">IChildNodeInMemoryCache (ThreadSafeChildNodeInMemoryCache)</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Common/Cache/ThreadSafeChildNodeInMemoryCache.cs&amp;sa=D&amp;source=editors&amp;ust=1740509661997816&amp;usg=AOvVaw2PtE_-S3_rec2zULHzrBNY">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`ThreadSafeChildNodeInMemoryCache` is responsible for one `Virtual Node&rsquo;s` cache. It handles operations for a single Node on `Hashing Ring` and all items assigned to that Hashing Ring. On top of that, it has supportive methods for rebalancing.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">private readonly VirtualNode _node;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly Dictionary&lt;uint, string&gt; _cache = new Dictionary&lt;uint, string&gt;();</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly SortedList&lt;uint, uint&gt; _sortedInAscCacheHashes = new SortedList&lt;uint, uint&gt;();</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly IReadWriteLockService _lockService;</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It keeps cache items in native Dictionary `_cache` and in SortedList `_sortedInAscCacheHashes`. We need a sorted list to be able to get the first half more easily and quickly when rebalancing. This service uses read-write lock service.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">There are 2 types of methods in this service with the prefix `NotSafe` and without the prefix (Safe).</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">NotSafe methods do not use the read-write lock. Those without prefixes - do. They are needed because some of the methods call other methods, and then nested locking happens which we would like to avoid.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Method for adding item to the cache:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public bool AddToCache(uint keyHash, string value)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var needRebalance = _lockService.Write(() =&gt;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _cache[keyHash] = value;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _sortedInAscCacheHashes[keyHash] = keyHash;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (GetCountOfItemsNotSafe() &gt;= _node.MaxItemsCount)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return needRebalance;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public bool AddToCacheNotSafe(uint keyHash, string value)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _cache[keyHash] = value;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _sortedInAscCacheHashes[keyHash] = keyHash;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (GetCountOfItemsNotSafe() &gt;= _node.MaxItemsCount)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Another interesting method is GetFirstHalfOfCache</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public Dictionary&lt;uint, string&gt; GetFirstHalfOfCacheNotSafe(uint lastItemToRemoveInclusively)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var halfCount = _cache.Count / 2;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var firstHalf = _sortedInAscCacheHashes.Where(k =&gt; k.Key &lt;= lastItemToRemoveInclusively).Take(halfCount).ToList();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var tailDelta = halfCount - firstHalf.Count;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (tailDelta &gt; 0)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //add from the tail</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var rest = _sortedInAscCacheHashes.Reverse().Take(tailDelta);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstHalf.AddRange(rest);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var halfDict = new Dictionary&lt;uint, string&gt;(halfCount);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var keyHash in firstHalf)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; halfDict.Add(keyHash.Key, _cache[keyHash.Key]);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return halfDict;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">```</span></p><p class="c2"><span class="c0">`lastItemToRemoveInclusively` - usually is just a Virtual Node position. It is different when we perform Rebalancing (see later in the article).</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>The tricky part of the method, is that we could have this situation.<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 120.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 120.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0"><br>Consider the Orange node, the first part of it is 5/2 = first 2 elements, which are 20, 21 and not 3, 4. This is the edge case when we need to take some elements from the tail as well.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.5cywm9cm3n97"><span class="c12">IChildNodeService</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.ChildNode/ChildNodeService.cs&amp;sa=D&amp;source=editors&amp;ust=1740509662002255&amp;usg=AOvVaw1IzYUFWOB5p0397bF6NVsK">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">IChildNodeService is the singleton service that handles requests from the Controller. It is a singleton because we would like to keep our in-memory cache items and Virtual Nodes alive as the service is alive</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">private readonly Dictionary&lt;uint, IChildNodeInMemoryCache&gt; _nodeToCacheMapping =</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new Dictionary&lt;uint, IChildNodeInMemoryCache&gt;();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; private readonly IRebalancingQueue _rebalancingQueue;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We keep `Virtual Nodes` in the dictionary as `ringPosition =&gt; ChildNodeInMemoryCache`. We ensure invariant that the Virtual Node position is unique across the Hashing Ring.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Rebalancing Queue is simply a Master Service client that will be called when some Virtual Node is overloaded. In theory, this should be some Messaging Queue Client that will send a rebalancing message to a queue, and then the Master picks up it and perform rebalancing.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">All requests that are related to a particular Virtual Node&rsquo;s cache are proxied to a particular ChildNodeInMemoryCache(ThreadSafeChildNodeInMemoryCache) depending on the request. </span></p><p class="c2"><span class="c0"><br>For example, here is AddValue (by key) method.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public async Task&lt;bool&gt; AddValueAsync(uint nodePosition, uint keyHash, string value, CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!_nodeToCacheMapping.ContainsKey(nodePosition))</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; throw new Exception($&quot;there is no node for {nodePosition}, please add virtual node&quot;);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var doesNeedRebalancing = _nodeToCacheMapping[nodePosition].AddToCache(keyHash, value);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (doesNeedRebalancing)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await _rebalancingQueue.EmitNodeRebalancingAsync(_nodeToCacheMapping[nodePosition].Node, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return doesNeedRebalancing;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The main functionality of this service is to keep and manage those Virtual Nodes.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public Task AddNodeAsync(VirtualNode node, CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _nodeToCacheMapping.Add(node.RingPosition, new ThreadSafeChildNodeInMemoryCache(node, new ReadWriteLockService()));</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Task.CompletedTask;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; public Task RemoveNodeAsync(uint position, CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _nodeToCacheMapping.Remove(position);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Task.CompletedTask;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.o2vxtwxbmdu0"><span class="c7">Load Balancer</span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 330.67px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 330.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Load Balancer is an HTTP service that is responsible for managing `Hashing Ring` and directing requests from the Client to a particular `Child Node`. The instance of Load Balancer should be considered as PhysicalNode.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.qcb6wgpcl7kw"><span class="c12">ILoadBalancerService</span></h3><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.LoadBalancer/LoadBalancerService.cs&amp;sa=D&amp;source=editors&amp;ust=1740509662005952&amp;usg=AOvVaw2wBGUROmabEyYD7MuBqsOt">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">This is the singleton service that handles requests from the Controller. It is a singleton because we would like to keep our in-memory Hashing Ring and Virtual Nodes alive as the service is alive.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It has `ChildNodeManager` (it is already described in `Common Services` section), IHashService to calculate the key hash for a particular key, and ChildNodeClient, which is just an Http client for ChildNode access.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`LoadBalancerService` has 2 responsibilities: </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`1.` Proxying requests to particular ChildNode</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public async Task&lt;string&gt; GetValueAsync(string key, CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var keyHash = _hashService.GetHash(key);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var virtualNode = _nodeManager.GetVirtualNodeForHash(keyHash);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var physicalNode = _nodeManager.ResolvePhysicalNode(virtualNode);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var value = await _childNodeClient.GetFromCacheAsync(keyHash, virtualNode, physicalNode, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return value;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`2.` Handling updates to Hashing Ring.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public Task AddVirtualNodeAsync(string physicalNodeUrl, VirtualNode virtualNode, CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var physicalNode = new PhysicalNode(new Uri(physicalNodeUrl));</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _nodeManager.AddVirtualNode(virtualNode, physicalNode);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return Task.CompletedTask;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.j7ih2fkexs1v"><span class="c7">Master </span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Master is an HTTP service that is responsible for managing and handling Physical Nodes including Child Nodes and Load Balancers. It does rebalancing, and spinning new instances of physical nodes. The instance of Master should be considered as PhysicalNode.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.m39zmaszrikh"><span class="c12">IMasterService</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://github.com/andreyka26-git/andreyka26-distributed-systems/blob/main/ConsistentHashing/src/DistributedCache.Master/MasterService.cs&amp;sa=D&amp;source=editors&amp;ust=1740509662008920&amp;usg=AOvVaw3kmZe2YX2JdX14Dmf3IQc3">Source Code</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">This is the singleton service that handles requests from the Controller. It is a singleton because we would like to keep our in-memory Hashing Ring and Virtual/Physical Nodes alive as the service is alive.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It has 2 clients: Child Node Client and Load Balancer Client, HashService to calculate ring position based on Url, &nbsp;PhysicalNodeProvider, ChildNodeManager, and AsyncSerializableLockService (we already discussed it in `Common Services`).</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We are performing all operations on master in a single-threaded manner so that no race conditions and inconsistencies can happen.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The most important method here is RebalanceNodeNotSafeAsync</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">public async Task RebalanceNodeNotSafeAsync(VirtualNode hotVirtualNode, CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var hotPhysicalNode = _nodeManager.ResolvePhysicalNode(hotVirtualNode);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var newPhysicalNode = await _physicalNodeProvider.CreateChildPhysicalNodeAsync(cancellationToken: cancellationToken);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var firstHalf = await _childClient.GetFirstHalfOfCacheAsync(hotVirtualNode, hotPhysicalNode, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var nodePosition = firstHalf.OrderBy(h =&gt; h.Key).Last().Key;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var newVirtualNode = new VirtualNode(nodePosition, hotVirtualNode.MaxItemsCount);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _nodeManager.AddVirtualNode(newVirtualNode, newPhysicalNode);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await _childClient.AddNewVirtualNodeAsync(newPhysicalNode, newVirtualNode, cancellationToken);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // first add items that are already in the cache to the new node, before updating load balancers. So once we update load balancer</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // it is probable that Client will find the item in newly created node</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await _childClient.AddFirstHalfToNewNodeAsync(firstHalf, newVirtualNode, newPhysicalNode, cancellationToken);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach (var loadBalancerNode in _physicalNodeProvider.LoadBalancers)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await _loadBalancerClient.AddVirtualNodeAsync(loadBalancerNode, newVirtualNode, newPhysicalNode, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // in case new items are added while we are updating load balancers - we get the first half again to include newly added and not lose data</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // since middle point could be shifted because of new data, we will discard all items that are greater than node&#39;s position on Child Node service</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // also, we don&#39;t overwrite duplicates, pretending the fresher data is on new Node, since Clients started writing there after updating load balancers</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var firstHalfAfterUpdating = await _childClient.GetFirstHalfOfCacheAsync(hotVirtualNode, hotPhysicalNode, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await _childClient.AddFirstHalfToNewNodeAsync(firstHalfAfterUpdating, newVirtualNode, newPhysicalNode, cancellationToken);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; await _childClient.RemoveFirstHalfOfCache(newVirtualNode.RingPosition, hotVirtualNode, hotPhysicalNode, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Let&rsquo;s visualize our system and how it will rebalance.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Assume we have `Master`, `Load Balancer`, and `Child Node`. `Child Node` has 1 Virtual Node with such key hashes (and some values, which are not important) [5, 7, 10, 12]. Let&rsquo;s also assume that Max Count of items in Virtual Nodes is 5. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Initial state: </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 304.00px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 304.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">We are adding 1 more key hash `3`. Now the count of items in `Child Node` is 5 and we need to rebalance. `Child Node` sends a request to `Master` to perform rebalancing.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span><br><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 304.00px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 304.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Then `Master` gets the first half from `Child Node1` for setting Hashing Ring position (last item in the first half), spins a new `Child Node (ChildNode2)`, and updates its own Hashing Ring and Node Manager.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 385.33px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 385.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`Master` inserts Virtual Node to `ChildNode2` (Physical Node) so that it can accept new requests. Then `Master` adds the first half of cache items to `ChildNode2`, so all Clients can find the items in the new node. Then it updates all `Load Balancers`, setting `ChildNode2` to their Hashing Rings so that clients start using the new `Child Node (ChildNode2)`.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 381.33px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 381.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Actually, this operation encountered a classical consistency problem in Distributed Systems. It has corner cases because the time, that lasts while we move the first half to the new `Child Node2` and update all the `Load Balancers` is not small, on top of that, we don&rsquo;t have atomic transactions here. During that time some Clients can write data to `ChildNode1` and then try to read it in `ChildNode2` (after `Load Balancers` update) &nbsp;where does not exist.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">One good approach is the approach used in Master-Leader database Replication that Martin Kleppmann described in his book [7]. The idea is simple, we take a snapshot and create a snapshot point. After we transferred the first half (our snapshot), we just transfer every data after the snapshot point until we are in sync. But it is too much for our demo. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 381.33px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 381.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Instead of this, after updating `Load Balancers` we just query the first half once more and write it to `ChildNode2` once more. </span></p><p class="c2"><span class="c0">On `Child Node` we drop all duplicates (old items), and all items that have a greater key hash than the ring position of Virtual Node where we transfer to because the middle point most probably will be shifted if we add new items.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">This way we will not lose data that was written before we finished updating all `Load Balancers` and after we moved the first half to `ChildNode2`. </span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Then we just remove the first half from `ChildNode1` starting from the lowest key hash up until `ChildNode2&rsquo;s` position inclusively.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Another topic is retry and failover, what to do if one Load Balancer goes down, or any of 2 nodes become unresponsive - but it is not a topic for this article.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">I am not sure it is the correct approach, so feedback is welcomed on my social media (`About` section) I will correct the algorithm.</span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.ti8650std5g"><span class="c7">DEMO</span></h2><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.owryvhrfw9vm"><span class="c12">Presetup</span></h3><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">For demo purposes, I have added Informational endpoints to show what data is actually in all Nodes, for example, Endpoint on Master Node:<br><br>```cs</span></p><p class="c2"><span class="c0">&nbsp;public async Task&lt;ClusterInformationModel&gt; GetClusterInformationAsync(CancellationToken cancellationToken)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var clusterInformation = new ClusterInformationModel();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(var loadBalancer in _physicalNodeProvider.LoadBalancers)</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var loadBalancerInformationModel = await _loadBalancerClient.GetLoadBalancerInformationModelAsync(loadBalancer, cancellationToken);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clusterInformation.LoadBalancerInformations.Add(new ClusterInformationModelItem</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LoadBalancerInfo = loadBalancerInformationModel,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PhysicalNode = loadBalancer</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return clusterInformation;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }<br>```</span></p><p class="c2"><span class="c0">It will go through each Load Balancer and grab info that each Load Balancer has. Load Balancer in Turn will query all the Child Nodes it knows about and aggregate this info for Master request.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">On top of that, we pre-setup our cluster from the Master node, on Startup:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">```cs</span></p><p class="c2"><span class="c0">async Task InitializeMasterAsync()</span></p><p class="c2"><span class="c0">{</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; using (var scope = app.Services.CreateScope())</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; var masterService = scope.ServiceProvider.GetRequiredService&lt;IMasterService&gt;();</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; // order matters</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; await masterService.CreateLoadBalancerAsync(7005, CancellationToken.None);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; await masterService.CreateLoadBalancerAsync(7006, CancellationToken.None);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; await masterService.CreateNewChildNodeAsync(7007, CancellationToken.None);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; await masterService.CreateNewChildNodeAsync(7008, CancellationToken.None);</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">}</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">It is simple, we are creating 2 Load Balancers and 2 Child Nodes in our cluster. The default Max count of items per Child Node is 5.</span></p><p class="c1"><span class="c0"></span></p><h3 class="c5" id="h.wccsr24e9hx5"><span class="c12">Rebalancing showcase</span></h3><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>Run the application, and it will spin 5 http services:<br><br>Master: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://localhost:7001/swagger/index.html&amp;sa=D&amp;source=editors&amp;ust=1740509662017456&amp;usg=AOvVaw0ToPisCxTHYOlgHDO6vJOx">https://localhost:7001/swagger/index.html</a></span><span><br>Load Balancer1: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://localhost:7005/swagger/index.html&amp;sa=D&amp;source=editors&amp;ust=1740509662017815&amp;usg=AOvVaw3R2SQUoUcciiEAXs8K2PJW">https://localhost:7005/swagger/index.html</a></span></p><p class="c2"><span>Load Balancer2: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://localhost:7006/swagger/index.html&amp;sa=D&amp;source=editors&amp;ust=1740509662018079&amp;usg=AOvVaw2dn_3qZKAc4QcA2oRaLgkA">https://localhost:7006/swagger/index.html</a></span></p><p class="c2"><span>Child Node1: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://localhost:7007/swagger/index.html&amp;sa=D&amp;source=editors&amp;ust=1740509662018286&amp;usg=AOvVaw1SeLrnsHNGabRJdl9nzvNF">https://localhost:7007/swagger/index.html</a></span></p><p class="c2"><span>Child Node2: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://localhost:7008/swagger/index.html&amp;sa=D&amp;source=editors&amp;ust=1740509662018501&amp;usg=AOvVaw0Texq_z0oSrPvUp11pthPJ">https://localhost:7008/swagger/index.html</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`1.` Let&rsquo;s query Cluster Information after everything is up</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 514.67px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 514.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">On the screen, &nbsp;you can see Load Balancer1&rsquo;s snapshot. It has 2 child nodes on 3147170649 and 1017285212 position</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`2.` Add 4 elements through Load Balancer API. </span></p><p class="c2"><span class="c0">I&rsquo;m adding this for demo purposes in this way:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`1 =&gt; 1`, `2 =&gt; 2`, `3 =&gt; 3` &hellip;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">After 4th added element, you might get lucky and add your value as 5th element that will trigger rebalancing.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span>I have added 6 elements, and I have this distribution of items<br><br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 622.67px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 622.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">`3.` Put one more item that will trigger rebalancing</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">I put &ldquo;7&rdquo;: &ldquo;7&rdquo;, and I noticed that the execution time was about 1-2 seconds.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">If you query Cluster Information (on Master level, or Load Balancer level) you will see, that there is new Child Node added on port `7010`<br><br>```json</span></p><p class="c2"><span class="c0">{</span></p><p class="c2"><span class="c0">&nbsp; &quot;childInformationModels&quot;: [</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &quot;physicalNode&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &quot;location&quot;: &quot;https://localhost:7007/&quot;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &quot;childInfo&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &quot;virtualNodesWithItems&quot;: [</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;node&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ringPosition&quot;: 3147170649,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;maxItemsCount&quot;: 5</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;cacheItems&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;2108632412&quot;: &quot;7&quot;,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;2582341876&quot;: &quot;6&quot;,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;2969606722&quot;: &quot;5&quot;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ]</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &quot;physicalNode&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &quot;location&quot;: &quot;https://localhost:7008/&quot;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &quot;childInfo&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &quot;virtualNodesWithItems&quot;: [</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;node&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ringPosition&quot;: 1017285212,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;maxItemsCount&quot;: 5</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;cacheItems&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;288247112&quot;: &quot;1&quot;,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;733514300&quot;: &quot;4&quot;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ]</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &quot;physicalNode&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &quot;location&quot;: &quot;https://localhost:7010/&quot;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &quot;childInfo&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &quot;virtualNodesWithItems&quot;: [</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;node&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;ringPosition&quot;: 1192688440,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;maxItemsCount&quot;: 5</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;cacheItems&quot;: {</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1137439682&quot;: &quot;2&quot;,</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;1192688440&quot;: &quot;3&quot;</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ]</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c2"><span class="c0">&nbsp; ]</span></p><p class="c2"><span class="c0">}</span></p><p class="c2"><span class="c0">```</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">You can open the swagger of the newly created node and check that it really contains those items that were added by rebalancing. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 773.33px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 773.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">You can see that when rebalancing the lowest 2 hashes were taken.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Indeed, while using Consistent Hashing, only O (n / m) items are moved between the nodes where n is the count of all items, and m is the count of all nodes. We had 2 nodes handling 6 items, 6 / 2 = 3. Actually, we moved only 2 items.</span></p><p class="c1"><span class="c0"></span></p><h2 class="c9" id="h.nqunhuug31co"><span class="c7">Summary</span></h2><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">In this article we ` implemented Distributed Cache` with all internals explained using `Consistent Hashing` algorithm. It is really simplified version and it does not cover a lot of corner cases. There is a reason why a really big team working on Redis for years, and still keep working on it. But we implemented the algorithm itself. We have partitioning and automatic rebalancing using the `Consistent Hashing` algorithm.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Please feel free to leave feedback - I will correct the mistakes that you mentioned.</span></p><p class="c2"><span><br>And separate thanks for reviewing to my friends: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://www.linkedin.com/in/o%25CE%25BBeh-kyshkevych-84a029205/&amp;sa=D&amp;source=editors&amp;ust=1740509662026634&amp;usg=AOvVaw0gFEhDy6A9RcQuXNwkDhBt">Oleh</a></span><span>&nbsp;and </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://www.linkedin.com/in/mykola-zaiarnyi-71433316b/&amp;sa=D&amp;source=editors&amp;ust=1740509662026831&amp;usg=AOvVaw2HVNbuyzG2zGwKjmcAip7f">Mykola</a></span></p><h2 class="c9" id="h.9qw3wjg9xgv"><span class="c7">References</span></h2><p class="c1"><span class="c0"></span></p><ol class="c11 lst-kix_h5fb79agmqr8-0 start" start="1"><li class="c2 c4 li-bullet-0"><span class="c0">[1] David Karger, Eric Lehman, Tom Leighton, Matthew Levine, Daniel Lewin, Rina Panigrahy: &ldquo;Consistent hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web&rdquo;, &nbsp;4 paragraph, 1997</span></li><li class="c2 c4 li-bullet-0"><span>[2] Wikipedia: Partition, </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://en.wikipedia.org/wiki/Partition_(database)&amp;sa=D&amp;source=editors&amp;ust=1740509662027329&amp;usg=AOvVaw2XY1BFOnwzza2o_Bd17DPV">https://en.wikipedia.org/wiki/Partition_(database)</a></span><span class="c0">&nbsp;</span></li><li class="c2 c4 li-bullet-0"><span class="c0">[3] Martin Kleppmann: &ldquo;Designing Data-Intensive Applications&rdquo;, page 203, March 2017</span></li><li class="c2 c4 li-bullet-0"><span class="c0">[4] Martin Kleppmann: &ldquo;Designing Data-Intensive Applications&rdquo;, page 214, March 2017</span></li><li class="c2 c4 li-bullet-0"><span class="c0">[5] Rick Kazman, Paul Clements, Len Bass: Software Architecture in Practice, page 5, 2013</span></li><li class="c2 c4 li-bullet-0"><span>[6] MongoDB official documentation: </span><span class="c3"><a class="c10" href="https://www.google.com/url?q=https://www.mongodb.com/docs/manual/core/sharded-cluster-components/&amp;sa=D&amp;source=editors&amp;ust=1740509662027787&amp;usg=AOvVaw2u4VC1wG5V8d6jE9v-FeC3">https://www.mongodb.com/docs/manual/core/sharded-cluster-components/</a></span><span class="c0">&nbsp;</span></li><li class="c2 c4 li-bullet-0"><span class="c0">[7] Martin Kleppmann: &ldquo;Designing Data-Intensive Applications&rdquo;, page 155, March 2017</span></li></ol></body></html>